# 블록체인 & Klaytn 정리 문서

 https://docs.klaytn.com 을 바탕으로 작성되었습니다. 

손세종님의 강의를 바탕으로 작성했습니다.





# Scalability

TPS + Block interval



Transaction Per Second : 초당 몇개의 거래 처리가 가능한가

Block Interval: 블록 생성의 간격



TPS 

ex)

Visa :tps 1700

비트코인 : TPS 7

이더리움 : TPS 15-20



Block interval

비트코인 10분

이더리움 15-20초

 

ETH : 20tps + 15sec block interval

-> 20* 15 = 300 transactions






# 기존 블록체인의 약점

왜 기존의 블록체인이 느린가?

블록체인 네트워크의 특성이 참여하는 노드가 많다고 해서 더 빨라지지 않는다.



네트워크 -> 사용자가 많아짐에 따라 분산하거나 서버를 증설



블록체인은 모든 노드들이 똑같은 일들을 반복 -> 성능이 제일 낮은 노드에 맞게 성능이 하향조정된다.



비트코인 & 이더리움

많은 양의 트랜젝션 처리하기에 부족하고

네트워크 자체의 속도가 느리다.






# Finality

Finality : tx가 변경 불가능하다라는 합리적인 보장을 받기까지 기다려야되는 시간.

변경 불가능한 최종적인 상태



블록이 Final 하다.

블록에 담긴 tx(거래)가 바뀔 수 없다는 것을 보증



비트코인과 이더리움 -> 최종성이 부족하다.

Ex) 상품을 구입 -> 거래가 기록이 되나 바로 처리가 되지 않음

확률적인 최종성만 제공

<img width="378" alt="스크린샷 2020-01-12 오후 7 38 25" src="https://user-images.githubusercontent.com/54495632/72217618-d6d4c180-3573-11ea-8eaf-1eee43a1df34.png">



최종성까지의 속도가 너무 비정상적이다.

빨리 처리된 Finality는 중요한 비지니스 자산.






# Fork

블록들의 연결이 2개이상의 분기로 갈라지는 현상



블록체인 p2p 네트워크에서 모든 참여자들이 독립적으로 채굴을 할 수 있기 때문에 발생한다.



작업증명 ( pow ) 방식

- 블록체인에 블록 추가하기 위해 문제를 품(Hash 값 찾기)
- 두 개의 노드에서 비슷한 시기에 문재를 해결되서 블록체인 후보자로 2개의 블록이 올라가고 분기가 발생한다






# Longest Chain Rule

Fork가 발생했을 때 더 길게 형성된 라인이 결국 다음 블록으로 인정이되고 블록체인에 추가되는 현상



<img width="458" alt="스크린샷 2020-01-12 오후 7 55 44" src="https://user-images.githubusercontent.com/54495632/72217722-8c544480-3575-11ea-9e63-b1a4bea5a992.png">



전체 51% 컴퓨팅 파워의 51% 이상을 가지고 있다면 다른 채굴자들에 비해 더 빨리 블록 생성이 가능하다.

다른 노드에게 형성을 알리지 않고 분기과정에서 계속 블록라인을 형성할 수 있음 

현금화 가정이나 거래 과정을 넣지 않을 수 있다. 거짓으로 블록에 추가할 수 있다.






# Consensus 

Public 블록체인 : POW POS

PRIVATE 블록체인 : pBFT ,Raft



BFT(비잔티움 결함 허용)

- 참여 노드수 제한/ 성능을 높임
- 분산화 약화 / 투명성 저하 (특정 그룹에게만 정보가 공개되기 때문)
- 블록체인 혜택을 의미있게 사용하지 못한다.



클레이튼 합의 알고리즘 IBFT(이스탄불 비잔티움 결함 허용) public + private

- 공개를 통한 개인적인 합의 신뢰 모델
- 합의 달성은 소수의 private 노드
- 블록 생성의 결과와 접근 및 검증 노드 -> 공개적






#  이스탄불 (I)BFT



<img width="466" alt="스크린샷 2020-01-12 오후 8 00 33" src="https://user-images.githubusercontent.com/54495632/72217810-8448d480-3576-11ea-990e-5ee97812789f.png">

크게 3 단계로 나누어져 있다.

1. pre - prepare 
2. prepare
3. commit



매 라운드 마다 Round Robin (RR) 방식의 스케쥴링을 이용하여 합의 노드들 중 proposer을 뽑는다.

제안자 proposer 외에 나머지 합의 노드들은 validator 로써 검증을 하게 된다.



Validator 3 이 검증자로써 제대로 동작하지 못하는 상황(컴퓨터 고장, 네트워크가 끊어짐,악의적 행동)



- Propose 

​      한 노드가 proposer로 선택이 된다.



- Pre-prepare

​      proposer 노드가   블록을 생성하고 다른 validator에게 제안을 하게 된다. 1 ,2,3 에게 보낸다.



- Prepare

  자신을 제외한 다른 노드들에게 성공적으로 받았다는 메세지를 전달한다. 자신 제외 각 3곳

  Validator3 노드는 fault -> 이 단계가 끝나면 총 몇 개의 노드가 살아있는지 확인할 수 있다.

​       

- Commit

  proposer 에게 받은 블록을 수락할 것인지 다른 노드들과 소통하며 결정하는 과정

  O / X 인지 각자 응답을 보낸다. 2/3 이상이 승인했다고 생각되면 결정되고 넘어감

  Finality 를 결정하고 마무리 짓는다.



장점 : 합의 노드들 끼리 통신을 통해 합의를 이끌어내고 그 즉시 완결성을 가진다. Finality

단점 : 합의 노드가 많아질수록 통신량이 기하급수적으로 늘어낸다. 

​           -> But, 합의 노드의 일부만 뽑아서 BFT를 형성하게 이루어진다. 






# Cycle(블록 생성 사이클)

- 블록 생성 주기 = 라운드(round)

  각 라운드는 새로운 블록을 생성하고 끝나는 즉시 새로운 라운드가 시작된다.

- 블록 생성의 간격은 1초






# Proposer and Committee Selection



제안자와 위원회 선택



<img width="558" alt="스크린샷 2020-01-12 오후 8 20 33" src="https://user-images.githubusercontent.com/54495632/72218001-0fc36500-3579-11ea-87de-de6631c5e1f3.png">

​                                                    파란색 노드 - Proposer , 핑크색 노드 - Validator

- 제안자를 random & deterministically(결정적) 으로 뽑지만 Governance Council 노드들 중에서 뽑게 된다.

​      @ Governance Council : core cell들의 집합 , 합의 노드들

- 각각의 합의 노드가 가장 최근의 블록헤더에서 파생된 난수를 사용하여 자기가 이 라운드에서 선택됐는지 증명하게되는 암호화 작업을 진행하게 된다.






# Block Proposal and Validation 

블록 제안과 검증



- 합의 노드가 proposer로 선택이 되면 자신이 그 라운드에서 제안자로 뽑히게 된 증거를 다른 노드들에게 전달하게 된다.

- 제안자의 공개키를 통해 입증가능한 암호증명을 쓴다.
- 해당 라운드에 위원회로 뽑힌 노드들은 반대로 증명하게 된다.
- 증명과정이 끝나고 누가 제안자이고 위원회인지 서로 파악이 되면 제안자가 블록을 만들고 합의








# Block Propagation (블록 전파)

제한된 블록은 성공적으로 완료되기 위해 validator 위원회의 2/3 이상의 동의를 필요로 한다.

위원회가 합의에 도달하면 새로운 블록이 모든 노드들에게 전달되고 합의 라운드는 끝이 난다.



<img width="700" alt="스크린샷 2020-01-12 오후 8 37 49" src="https://user-images.githubusercontent.com/54495632/72218177-70ec3800-357b-11ea-98fb-bea2765f806b.png">

- 프록시 노드를 통해 end point 노드들에게 전달이 된다.








# 네트워크 구조



<img width="1131" alt="스크린샷 2020-01-12 오후 8 50 12" src="https://user-images.githubusercontent.com/54495632/72218315-2b306f00-357d-11ea-9ee7-9a8ce5cf0088.png">



전체 네트워크 core cell network + endpoint node network

코어셀 네트워크를 엔드포인트 노드 네트워크가 둘러싸고 있는 모양이다.



노란 색 부분 - CNN Consensus Node Network 합의 노드 네트워크 -> 합의를 담당하게 되는 노드들을 포함

빨간 색 부분 - PNN Proxy Node Network



하나의 코어셀은 하나의 참여자가 운영하게 된다. 한 개의 CN과 CN과 연결되어있는 여러 개 PN으로 운영된다.



CN으로 참여하기 위해서는 여러 조건을 갖추어야 하며 CN 간의 소통이 계속 이루어질 수 있도록 각자 간 모두 연결되어 있는 구조를 가진다. 합의 하는 과정에서 최대한 빠르게 소통해야 되므로 연결된 구조를 가진다.

CN들은 외부와 직접적으로 접촉할 수 없으며, 방해가 없는 PRIVATE 한 환경이다. 때문에 합의 노드로써, 블록을 만드는 결정에 빠르게 도달할 수 있는 장점이 있다.

외부와의 접근 자체는 Core Cell 참여자로써 본인이 운영하고 믿을 수 있는 PN을 앞에 내세워서 외부 end point와 소통한다.



EN 들이 PN와 연결되어 외부와의 소통이 가능하다.  EN 끼리 연결도 가능하다.



EN가 되는 조건은 없으며 웹이나 모바일 클라이언트에게 정보를 제공할 수 있다. 서비스 제공자로써의 역할을 하는 것이 EN이다.



Boot Node : 새로 들어온 노드가 네트워크에 등록하고 다른 노드에 연결하도록 도움을 주는 특수 유형 노드이다.

CN boot Node는 공개 x , 나머지 PN과 EN boot node는 공개가 된다.



PN boot Node는 허용된 PN만 등록하게 도와주고 EN과 연결이 되도록 도와준다.

EN boot Node는 어떤 Node에 연결이 될지 도와주는 역할을 한다.






# Core Cell 

합의를 담당하는 메인넷이 런칭이 되면 몇 십대 정도로 운영이 된다.

사용자가 많아져서 확장이 필요할 때

- 일반적인 경우 서버를 늘리고 Request를 분할 처리



블록체인의 경우 노드가 늘어난다고 해서 성능이 늘어나지 않는다. 더 줄어들 수 있음 생긴 만큼 다시 정보전달

- 클레이튼 : 노드 자체의 성능을 증가시킴



CN (합의 노드) 참여조건

참여자가 가지고 있는 성능

- physical core가 40 개 이상
- 256GB RAM
- 1년치의 데이터 14TB 저장
- 10G 네트워크

하나 노드의 성능이 특별히 좋다고 해서 core cell의 네트워크가 좋아지지 않는다.



-> 전체가 같은 스펙에 맞춰 성능향상을 시켜야 한다.

<img width="1138" alt="스크린샷 2020-01-12 오후 9 09 22" src="https://user-images.githubusercontent.com/54495632/72218599-d5a99180-357f-11ea-965b-f3fd0e3fc1b7.png">



Core Cell 의 구조 : 하나의 CN과 여러 개의 PN으로 이루어져 있다. 



@PN이 여러대 있는 이유

CN이 연결에 필요한 자원은 제한적이고  CN역시 수가 한정되어있어 PN을 이용해서 EN 연결을 지원한다.



Ex) EN들이 CN과 직접적으로 연결 가능

CN이 1000까지 연결허용 , 그 이상 연결하게 되면 부담이 되고 이상현상이 발생할 수 있게 된다.





그래서 PN이 그 역할을 대신하게 된다. EN에서 넘어온 정보들을 CN에 전달하고

CN은 PN 몇 대만 연결하면 되기 때문에 부담이 훨씬 덜 하다.

Core cell에 연결하려는 EN 들의 문제점을 해결할 수 있게 된다.



즉, CN은 합의를 결정하기 위한 노드이기 때문에 연결로 인해 성능 저하가 발생해서는 안된다.

그래서, PN이 CN을 보호해주는 역할이고 CN이 PN을 하위계층으로 여러 대 설정하므로써 확장성 문제도 해결이 가능하다.






# 서비스 체인

메인 넷과 연결된 독립적으로 운영되는 블록체인이다.

확장성을 기반으로 두고 나온 아이디어 이다.



@이용상황

- Bapp이 특별한 노드 환경에서 설정되야 하는 경우
- 보안 수준을 맞춤형으로 설정하고 싶은 경우 ex) Private 블록체인 운용하고 싶은 경우
- 매우 많은 처리량을 요구 하는 경우 / 메인넷에 배포 시 경제성이 낮은 경우



<img width="885" alt="스크린샷 2020-01-12 오후 9 40 57" src="https://user-images.githubusercontent.com/54495632/72218976-43f05300-3584-11ea-9b8d-f556d408ddef.png">

메인넷과 체인으로 연결된 것 -> 서비스 체인

서비스 체인이 메인넷의 신뢰를 고정시킨다고 볼 수 있다. 

메인넷과 서비스 체인간의 서비스 소통이 자유로운 것은 아니며 오직 제한된 transaction만이 사용될 수 있다.

또한, 클레이의 전송도 추후 제약조건이  존재하는 경우 허용된다.



서비스 체인은 독립된 서비스 공간을 구축해서 필요할 때 메인넷에 신뢰를 고정시키는 것이다.



타 블록체인 플랫폼에서도 채택하려는 움직임이 있다.



클레이튼의 서비스 체인안에서는 transaction에 소요되는 gas 비용을 안받게 설정하는 것도 가능하다.






# 이더리움과 클레이튼의 차이

이더리움

PoW : Proof-of-Work 알고리즘 작업증명방식

- 단일 네트워크 , 네트워크 구성원 간의 구분이 없다. 누구나 블록을 생성할 수 있음
- 단 가장 먼저 블록을 만들고 최대한 많은 곳에 전파를 해야된다. 그렇게 하게 되면 보상으로 토큰을 받게 된다.



마이닝 노드 : 블록을 쓰고 네트워크에 전파한 노드

블록을 채굴하는 노드가 누가될지 모르기 때문에 최대한 많은 노드들에게 붙어야 한다.



<img width="1143" alt="스크린샷 2020-01-12 오후 10 01 31" src="https://user-images.githubusercontent.com/54495632/72219280-b6166700-3587-11ea-9b59-8e4171e39035.png">

 

@ Write를 한 노드가 담당하는 경우

블록을 Write하는 노드들은 최신 정보를 가지고 있다. 

그래서 정보를 최대한 빠르게 얻어야 하는데 해당 노드가 어디에 있는지 알 수 없다.

A노드에서 항상 블록을 Write 하는 경우에 해당 노드 옆에 붙어 있기만 하면 가장 빠르게 정보를 받아볼 수 있게 된다. 





<img width="1112" alt="스크린샷 2020-01-12 오후 10 05 15" src="https://user-images.githubusercontent.com/54495632/72219282-b7e02a80-3587-11ea-8753-edb3dfe7b2c9.png">

@ 이더리움

그러나, 이더리움은 write 역할의 노드가 항상 바뀌기 때문에 최대한 많은 노드들에게 붙어 정보를 받아야 한다.

최대한 많은 노드들과 연결, 소통하고 블록 전파에 기여해야 확률적으로 최신 정보를 가져올 수 있는 확률이 증가하게 된다. 



<img width="1665" alt="스크린샷 2020-01-12 오후 10 09 37" src="https://user-images.githubusercontent.com/54495632/72219401-10fc8e00-3589-11ea-8f73-08e397b000c9.png">



@클레이튼

- Two Layer Architecture Trust Model (단일 네트워크가 아니고 2개의 Layer를 가지고 있는 네트워크 이다.)
- Core Cell 합의 노드 중 매 라운드마다 (RR 방식으로 채택) 하나의 노드가 뽑혀서 블록을 Write하게 된다.
- 최신 정보를 받기 위해서는 core cell 안에 있는 노드들에 붙어야 한다.
- 직접적으로 Core cell과 연결될 수 없으므로 블록체인에 접근하려면 해당 서버를 endpoint 에 연결 해야 한다. = 해당 컴퓨터를 EN 화 시켜서 연결 또는 다른 EN에 연결하여 사용한다.
- 이더리움과는 달리 메인과 부분적으로 소통할 수 있으며 독립적으로 운용할 수 있는 서비스 체인이 존재한다.



블록체인 시스템에서 EN를 개인적으로 운용하여 사용하기 위해서는 모든 블록들을 동기화하여 사용해야되기 때문에 어려움이 있다. 즉, 새로운 블록들이 추가될 때 마다 계속해서 동기화를 시켜줘야된다. 또한, 공격을 받아서 컴퓨터에 에러가 발생할 수 있는 가능성도 존재한다.



